`timescale 1ps / 1ps
//***********************************************************************//
//                                                                       //
//------------------------  Reed Solomon Encoder  -----------------------//
//                                                                       //
//***********************************************************************//
// The outgoing data generated by Frame Gen is encoded using Reed-Solomon//
// codes. 
//      start - begins encoding process, must toggle once per process.
//      clk_en - is almost always 1'b1
module reed_solomon_encoder_process #(
    parameter MESSAGE_LEN = 239
)(
    input wire clk,
    input wire reset,
    input wire [31:0] txdata,
    input wire start, 
    input wire clk_en,
    output wire endIn,
    output wire validIn,
    output wire [31:0] txdata_encoded,
    output wire clk_en_out,
    output wire startOut,
    output wire endOut,
    output wire validOut
);

    reg [31:0] counter = 0;
    // valid in will be 1 when startIn is 1 and will be 0 AFTER endIn is 1
    reg encoder_startIn;
    reg encoder_endIn;
    reg encoder_validIn = 0;

    wire [3:0] clk_en_out_i;
    wire [3:0] startOut_i;
    wire [3:0] endOut_i;
    wire [3:0] validOut_i;

    reg count_enable;

    // counter will be set after start is toggled. In order to ensure that
    // the correct amount of data is being received into the txdata input,
    // start at 1 and stop the counter at MESSAGE_LEN - 1, this will count
    // MESSAGE_LEN amount of times

    always@(posedge clk) begin
        if (start) begin
            counter <= 1;
            count_enable <= 1'b1;
        end
        else if (counter < MESSAGE_LEN && count_enable) begin
            counter <= counter + 1;
        end
        else if (counter == MESSAGE_LEN) begin
            counter <= 0;
            count_enable <= 1'b0;
        end
    end

    always@(posedge clk) begin
        if (start)
            encoder_validIn <= 1'b1;
        else if (encoder_endIn == 1'b1)
            encoder_validIn <= 1'b0;
    end
    

    always@(posedge clk) begin
        if (counter == MESSAGE_LEN - 1) begin // is set after MESSAGE_LEN-1
            encoder_endIn <= 1'b1;
        end else begin
            encoder_endIn <= 1'b0;
        end
    end

    always@(posedge clk) begin
        if (start)
            encoder_startIn <= 1'b1;
        else 
            encoder_startIn <= 1'b0;
    end

    genvar i;
    generate
        for(i = 0; i < 4; i = i + 1) begin
            RS_Encoder enc
            (
                .clk        (clk),
                .reset      (reset),
                .clk_enable (clk_en),
                .dataIn     (txdata[i*8 + 7:i*8]),
                .startIn    (encoder_startIn),
                .endIn      (encoder_endIn),
                .validIn    (encoder_validIn),
                .ce_out     (clk_en_out_i[i]),    // wire to clock enable for decoder
                .dataOut    (txdata_encoded[i*8 + 7:i*8]),
                .startOut   (startOut_i[i]),          // wire to start in for decoder
                .endOut     (endOut_i[i]),            // wire to end out of decoder
                .validOut   (validOut_i[i])           // wire to valid in of decoder
            );
        end
    endgenerate

    assign clk_en_out = &clk_en_out_i;
    assign startOut = &startOut_i;
    assign endOut = &endOut_i;
    assign validOut = &validOut_i;

    assign endIn = encoder_endIn;
    assign validIn = encoder_validIn;
endmodule
